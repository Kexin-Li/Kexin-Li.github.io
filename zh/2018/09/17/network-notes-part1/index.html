

<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />

  <meta name="theme-color" content="#42dbbc" />
  <meta name="msapplication-navbutton-color" content="#f8f5ec" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec" />

  
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico" />
  

  <title>MOS</title>

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">

  
    <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
  

  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

  <link rel="stylesheet" href="/css/style.css">

  

  <script>
    window.config = {"title":"MOS","subtitle":"I Must Go Seek Some Dewdrops","description":null,"author":"mos li","language":"en-US","timezone":null,"url":"https://kexin-li.github.io","root":"/","permalink":":lang/:year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":lang/:title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":"atom-one-light","default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"cicada","deploy":{"type":"git","repo":"https://github.com/Kexin-Li/kexin-li.github.io.git","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"search":{"path":"search.xml","field":"post","format":"html","limit":10000},"feed":{"type":"atom","limit":20,"hub":null,"content":null,"content_limit":140,"content_limit_delim":" ","path":"atom.xml","order_by":"-date"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"favicon":"/images/favicon.ico","menu":{"home":"/","archives":"/archives","portfolio":"/portfolio","about":"/about"},"show_tag":true,"show_category":false,"excerpt_link":"Read More","fancybox":true,"disqus_shortname":"Shingooo","rss":"default","social":{"email":"hollalikexin@gmail.com","instagram":"https://www.instagram.com/hollalikexin/","douban":null,"linkedin":null,"weibo":null,"stackoverflow":"https://stackoverflow.com/users/6737259/kexin-li","facebook":null,"twitter":null,"github":"https://github.com/Kexin-Li","google":null,"zhihu":null,"pocket":null},"friends":null,"google_analytics":"UA-124632979-1","portfolio":{"subtitle":"Some Works","cards":{"card1":{"cover":"/images/screenshot.png","content":"Cicada is a concise and retro theme for Hexo.","link":"https://github.com/Kexin-Li/hexo-theme-cicada"},"card2":{"cover":"/images/RSpotify.png","content":"RSpotify is a Spotify Client Build with React & Redux.","link":"https://github.com/Kexin-Li/RSpotify"}}},"about":{"subtitle":"Just Another Software Engineer"},"todaypoem":false};
  </script>
</head>
  <body>
    

<header class="blog-slide" style="height: px">
  <nav class="blog-header">
    <a class="mobile toggle-button"><i class="fas fa-bars fa-lg"></i></a>
    <ul>
      <li class="title"><a href="/">MOS</a></li>
      
        <li class="nav-item"><a href="/">Home</a></li>
      
        <li class="nav-item"><a href="/archives">Archives</a></li>
      
        <li class="nav-item"><a href="/portfolio">Portfolio</a></li>
      
        <li class="nav-item"><a href="/about">About</a></li>
      
    </ul>
  </nav>
  <h1 class="subtitle"><span id='jinrishici-sentence'>I Must Go Seek Some Dewdrops</span></h1>
</header>
    <nav id="menu">
  
    <a href="/">Home</a>
  
    <a href="/archives">Archives</a>
  
    <a href="/portfolio">Portfolio</a>
  
    <a href="/about">About</a>
  
</nav>
    
    <main class="blog-main" style="margin-top: -150px">
      <article class="blog-post">
  
    <div class="post-img" style="background-image: url(/assets/4.jpg)">
    </div>
  

  <div class="post-content post-typo">
    <div class="post-header">
      
        
  
    <h1 class="post-title">
      <a href="/zh/2018/09/17/network-notes-part1/">
        网络基础知识备忘录(一)
      </a>
    </h1>
  

<div class="post-meta">
  2018-09-17
  
  
</div>

      
    </div>
    <div class="post-detail">
      
        <blockquote>
<p>对于我来说网络知识是属于比较抽象的部分，很多东西不记录下来很快就会忘记。所以有了这个网络基础知识的备忘录。这是第一部分，<a href="https://kexin-li.github.io/zh/2018/10/08/network-notes-part2/">第二部分见这里</a> :)</p>
</blockquote>
<a id="more"></a>
<h2 id="URI-amp-URL"><a href="#URI-amp-URL" class="headerlink" title="URI &amp; URL"></a>URI &amp; URL</h2><p>URL(Uniform Resource Locator): 统一资源定位符。URL 就是我们平时在浏览器中输入的网址，比如 <a href="https://kexin-li.github.io">https://kexin-li.github.io</a> 就是 URL。<br>URI(Uniform Resource Identifier): 统一资源标识符。</p>
<p><strong>Uniform:</strong> 规定统一的格式用于方便地处理不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式，另外加入新增的协议方案（如 http: 或 ftp:）也更容易。<br><strong>Resource:</strong> 资源的定义是“可标识的任何东西”，除了文档文件、图片或服务等能够区别于其他类型的，全都可作为资源。并且资源不仅仅是单一的，也可以是多数的集合体。<br><strong>Identifier:</strong> 表示可标识的对象。</p>
<p>综上，URI 就是由某个协议方案表示的资源的定位标识符。</p>
<p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地址。<strong>URL 是 URI 的子集。</strong></p>
<h3 id="URI-的格式"><a href="#URI-的格式" class="headerlink" title="URI 的格式"></a>URI 的格式</h3><figure><img src="http://pek9gdw3x.bkt.clouddn.com/uri.png" alt="URI Format"><figcaption>URI Format</figcaption></figure>

<p>其中，登录信息、服务器端口号、查询字符串和片段标识符为可选项。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS(Domain Name System) 服务是和 HTTP 协议一样位于应用层的协议，DNS 主要提供域名到 IP 地址的解析服务。用户使用域名而非 IP 地址来访问对方的计算机，因为这比较符合人类的记忆习惯，但要让计算机去理解名称就有点难度了，因此 DNS 就充当了“翻译官”的角色，来将域名翻译成计算机更容易理解的 IP 数字串。</p>
<p>DNS 协议通过域名查找 IP 地址，或者逆向从 IP 反查找域名。</p>
<p>DNS 具体是如何工作的可参考<a href="https://www.cloudflare.com/learning/dns/what-is-dns/" target="_blank" rel="noopener">这篇文章</a>。</p>
<h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h2><p>计算机与网络设备互相通信，双方需要基于相同的规则，我们把这种规则叫做协议（protocol），而协议中存在各式各样的内容，像这样把互联网相关联的协议集合起来总称为 TCP/IP。通常使用的网络都是在 TCP/IP 协议族的基础上运作的，比如 HTTP 协议就是它内部的一个子集。</p>
<p>在 TCP/IP 协议族里最重要的一点是分层，它按层次分别分为以下四层：应用层、传输层、网络层和数据链路层。将 TCP/IP 层次化的好处是，我们只需要定好各层的接口，有变动时只需要更改对应层而不需要更改全部，各层之内也能自由设计，这也是所谓的“模块化”吧。</p>
<p>各层的作用如下：</p>
<p><strong>应用层</strong><br>应用层决定了向用户提供应用服务时通信的活动。比如 FTP(File Transfer Protocol, 文件传输协议)，DNS(Domain Name System, 域名系统) 和 HTTP 协议都在这层。</p>
<p><strong>传输层</strong><br>传输层对于上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP(Transmission Control Protocol, 传输控制协议) 和 UDP(User Data Protocol, 用户数据报协议)。</p>
<p><strong>网络层</strong><br>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小单位，该层规定了通过怎样的路径（即传输线路）到达对方计算机，并把数据包传给对方。</p>
<p><strong>链路层</strong><br>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡及光纤等物理可见部分。硬件上的范畴均属于链路层的作用范围之内。</p>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方计算机通信。发送端从应用层往下走，接收端则从链路层往上走。</p>
<p>以 HTTP 举例来说，对于发送端：</p>
<ul>
<li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li>
<li>接着为了传输方便，在传输层（TCP 协议）把从应用层收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li>
<li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。</li>
</ul>
<p>而对于接收端，在链路层接收到数据后，按序向上转发，一直到应用层。</p>
<p>另外，发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息；而接收端在层与层之间传输数据时，每经过一层时会把对应的首部去掉。这种把数据信息包装起来的做法称为封装（encapsulate）。</p>
<h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>IP(Internet Protocol) 协议位于 TCP/IP 协议族的网络层。几乎所有使用网络的系统都会用到 IP 协议，它的作用时把各种数据包传送给对方。而要保证确实送到对方那里，则需要满足各类条件，其中两个重要条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p>
<p>IP 地址指明了节点被分配到的地址，是可变的，MAC 地址指网卡所属的固定地址，是不可变的。IP 地址可以和 MAC 地址进行配对。</p>
<p>IP 间的通信依赖 MAC 地址，ARP 协议（Address Resolution Protocol）是一种解析地址的协议，能够根据通信方的 IP 地址反查出对应的 MAC 地址。在网络上，通常是经过多台计算机和网络设备中转才能连接对方，而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。</p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP(Transmission Control Protocol) 协议位于传输层，提供可靠的字节流服务。字节流服务是指将大块数据分割成以报文段（segment）为单位的数据包进行管理，而可靠的传输服务是指能够准确地把数据传给对方。</p>
<p><strong>三次握手策略</strong></p>
<p>为了保证传输的可靠性，TCP 协议采用三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，它不会就置之不理了，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志 SYN(synchronize) 和 ACK(acknowledgement)。</p>
<p>三次握手的过程如下：</p>
<ul>
<li>发送端首先发送一个带 SYN 标志的数据包给对方。</li>
<li>接收端收到后，回传一个 SYN/ACK 标志的数据以示确认信息。</li>
<li>发送端再回传一个带 ACK 标志的数据包，代表握手结束。</li>
</ul>
<p>若握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<p>图示过程如下：</p>
<figure><img src="http://pek9gdw3x.bkt.clouddn.com/tcp-shaking.png" alt="tcp shaking"><figcaption>TCP 三次握手过程</figcaption></figure>

<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务端之间的通信。它通过请求和响应交换达成通信，其中客户端发送请求，服务端响应请求。</p>
<p>客户端请求报文是由请求方法、请求 URI（用于定位资源）、协议版本、可选的请求首部字段和内容实体构成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法     URI       协议版本</span><br><span class="line">POST  /form/entry  HTTP/1.1</span><br><span class="line"></span><br><span class="line">请求首部字段</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 16</span><br><span class="line"></span><br><span class="line">内容实体</span><br><span class="line">name-ueno&amp;age=37</span><br></pre></td></tr></table></figure>
<p>服务器接收到请求后，会将请求内容的处理结果以响应的形式返回。响应报文基本上由协议版本、状态码、用以解释状态码的原因的短语、可选的响应首部字段以及实体主体构成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">协议版本  状态码   状态码的原因短语</span><br><span class="line">HTTP/1.1   200     OK</span><br><span class="line"></span><br><span class="line">响应首部字段</span><br><span class="line">Date: Tue, 18 Sep 2018 06:20:47 GMT</span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">资源主体（entity body）</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>HTTP/1.1 请求方法</strong><br>HTTP/1.1 支持的方法和 HTTP/1.0 支持的方法有所不同，这里只列举了 HTTP/1.1 所支持的方法。另外，方法名区分大小写。</p>
<p><strong>GET: 获取资源</strong><br>GET 方法用来请求访问已被 URI 识别的资源，指定的资源经服务器解析后返回的响应内容。</p>
<p><strong>POST: 传输实体主体</strong><br>POST 方法用来传输实体的主体。</p>
<p><strong>PUT: 传输文件</strong><br>PUT 方法用来传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但由于此方法自身不带任何验证机制，任何人都可以上传，因此存在安全性问题，一般不使用该方法。若配合 Web App 的验证机制，或架构设计采用 REST 标准的同类 Web 网站，则可能使用该方法。</p>
<p><strong>HEAD: 获得报文首部</strong><br>HEAD 方法和 GET 方法一样，只是不返回报文主体内容，只返回首部。用于确认 URI 的有效性及资源更新的日期时间等。</p>
<p><strong>DELETE: 删除文件</strong><br>DELETE 方法和 PUT 方法相反，用于删除指定资源。但和 PUT 方法一样，不带验证机制，存在安全性问题，一般也不使用该方法。</p>
<p><strong>OPTIONS: 询问支持的方法</strong><br>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</p>
<p><strong>TRACE: 追踪路径</strong><br>TRACE 方法让 Web 服务器端将之前的请求通信环回给客户端。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这样因为请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认这一连接过程中发生了什么的。但由于此方法容易导致 XST(Cross-Site Tracing, 跨域追踪)，因此基本不用。</p>
<p><strong>CONNECT: 要求用隧道协议连接代理</strong><br>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL(Secure Sockets Layer, 安全套接层) 和 TLS(Transport Layer Security, 传输层安全) 协议把通信内容加密后经网络隧道传输。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议是一种不保存状态，即无状态（stateless）的协议。也就是说协议本身不保存之前一切的请求或响应报文信息，这样设计的好处在于能够更快地处理大量事务，但随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况越来越多。比如用户登录到一家购物网站，即使它跳转到其他页面后，也需要保持登录状态。因此，<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">Cookie 技术</a>应运而生。Cookie技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p>Cookie 会根据服务端发送的响应报文内一个叫做 <code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。此时的服务端会根据 Cookie 去检查是哪一个客户端发来的信息，对比服务器上的内容得到之前的状态信息。</p>
<h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文，它是 HTTP 通信中的基本单位。报文是由多行数据构成的字符串文本。请求端的叫请求报文，响应端的叫响应报文。HTTP 报文大致可分为报文首部和报文主体两部分，报文主体可以不存在。</p>
<p>报文首部由以下数据组成：</p>
<ul>
<li>请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。</li>
<li>状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。</li>
<li>首部字段：包含表示各种请求和响应的条件和属性的首部，一般有通用首部、请求首部、响应首部和实体首部四种。</li>
<li>其他：可能包含 HTTP 的 RFC 里未定义的首部(Cookie 等)。</li>
</ul>
<h3 id="HTTP-报文首部"><a href="#HTTP-报文首部" class="headerlink" title="HTTP 报文首部"></a>HTTP 报文首部</h3><p>HTTP 请求报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。HTTP 响应报文由 HTTP 版本、状态码(数字和原因短语)、HTTP 首部字段 3 部分构成。HTTP 首部字段的信息最为丰富，根据实际用途可以被分为以下 4 种类型：</p>
<ul>
<li>通用首部字段：请求报文和响应报文两方都会使用的首部。</li>
<li>请求首部字段：从客户端向服务端发送请求报文时使用的首部。</li>
<li>响应首部字段：从服务端向客户端返回响应报文时使用的首部。</li>
<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部。</li>
</ul>
<p><strong>通用首部字段：</strong></p>
<ul>
<li>Cache-Control</li>
<li>Connection</li>
<li>Date</li>
<li>Pragma</li>
<li>Trailer</li>
<li>Transfer-Encoding</li>
<li>Upgrade</li>
<li>Via</li>
<li>Warning</li>
</ul>
<p><strong>请求首部字段：</strong></p>
<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Authorization</li>
<li>Expect</li>
<li>Form</li>
<li>Host</li>
<li>If-Match</li>
<li>If-Modified-Since</li>
<li>If-None-Match</li>
<li>If-Range</li>
<li>If-Unmodified-Since</li>
<li>Max-forwards</li>
<li>Proxy-Authorization</li>
<li>Range</li>
<li>Referer</li>
<li>TE</li>
<li>User-Agent</li>
</ul>
<p><strong>响应首部字段：</strong></p>
<ul>
<li>Accept-Ranges</li>
<li>Age</li>
<li>ETag</li>
<li>Location</li>
<li>Proxy-Authenticate</li>
<li>Retry-After</li>
<li>Server</li>
<li>Vary</li>
<li>WWW-Authenticate</li>
</ul>
<p><strong>实体首部字段：</strong></p>
<ul>
<li>Allow</li>
<li>Content-Encoding</li>
<li>Content-Language</li>
<li>Content-Length</li>
<li>Content-Location</li>
<li>Content-MD5</li>
<li>Content-Range</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
</ul>
<p><strong>为 Cookie 服务的首部字段：</strong></p>
<ul>
<li>Set-Cookie</li>
<li>Cookie</li>
</ul>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>状态码用来描述客户端向服务端发送请求后的结果。借助状态码就可以分析服务端是否正常处理了请求。状态码的类别如下：</p>
<ul>
<li>1XX: Informational, 接收的请求正在处理。</li>
<li>2XX: Success, 请求正常处理完毕。</li>
<li>3XX: Redirection, 需要进行附加操作以完成请求。</li>
<li>4XX: Client Error, 服务器无法处理请求。</li>
<li>5XX: Server Error, 服务器处理请求出错。</li>
</ul>
<h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><p>2XX 的响应结果表明请求被正常处理了。</p>
<p><strong>200 OK</strong><br>表示从客户端发来的请求在服务端被正常处理了。</p>
<p><strong>204 No Content</strong><br>表示服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。</p>
<p><strong>206 Partial Content</strong><br>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。</p>
<h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><p>3XX 的响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<p><strong>301 Moved Permanently</strong><br>表示永久性重定向。即请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</p>
<p><strong>302 Found</strong><br>表示临时性重定向。即请求的资源已被分配了新的 URI，希望用户本次能使用新的 URI 访问。</p>
<p><strong>303 See Other</strong><br>表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p>
<p><strong>304 Not Modified</strong><br>表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件。304 虽然被划分在 3XX 类别中，但和重定向没有关系。</p>
<p><strong>307 Temporary Redirect</strong><br>与 302 有着相同的含义。</p>
<h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<p><strong>400 Bad Request</strong><br>表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。</p>
<p><strong>401 Unauthorized</strong><br>表示发送的请求需要有通过 HTTP 认证的认证信息。</p>
<p><strong>403 Forbidden</strong><br>表示对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题等等都可能是发生 403 的原因。</p>
<p><strong>404 Not Found</strong><br>表示服务器上无法找到请求的资源。</p>
<h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><p>5XX 的响应结果表明服务器是发生错误的原因所在。</p>
<p><strong>500 Internal Server Error</strong><br>表示服务器在执行请求时发生了错误。</p>
<p><strong>503 Service Unavailable</strong><br>表示服务器正处于超负载或正在停机维护的状态，而无法处理请求。</p>

        <hr>
      
    </div>

    
      
    

    
      
  
  
  <div class="post-tags">
    <a href="/tags/network/">#network</a>
  </div>
  <hr>
  

      <div class="post-more">
  
    <div class="post-pre">
      <span>previous</span>
      <a href="/zh/2018/09/20/what-is-scope-and-closures/">JavaScript 作用域与闭包</a>
    </div>
  
  
  <div class="post-next">
    <span>next</span>
    <a href="/zh/2018/09/14/how-react-works/">解析 React 工作流程</a>
  </div>
  
</div>
      
  <div class="post-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </div>

    
  </div>
</article>

    </main>
    
    <div class="back-to-top" id="back-to-top"><i class="fas fa-arrow-alt-circle-up fa-2x"></i></div>

    <footer class="blog-footer">
  


  


  <div class="blog-footer-social">
    <ul>
      
        
          <li><a class="iconfont icon-email" href="mailto:hollalikexin@gmail.com"></a></li>
        
      
        
          <li><a class="iconfont icon-instagram" href="https://www.instagram.com/hollalikexin/"></a></li>
        
      
        
          <li><a class="iconfont icon-stackoverflow" href="https://stackoverflow.com/users/6737259/kexin-li"></a></li>
        
      
        
          <li><a class="iconfont icon-github" href="https://github.com/Kexin-Li"></a></li>
        
      
      
        <li><a class="iconfont icon-rss" href="/atom.xml"></a></li>
      
    </ul>
  </div>
 
  <div class="blog-footer-copyright">
  <p class="copyright">Copyright © 2018 mos li. Powered by <a href="https://hexo.io/">Hexo</a> and <a href="https://github.com/Kexin-Li/hexo-theme-cicada">Cicada</a>. <iframe src="https://ghbtns.com/github-btn.html?user=Kexin-Li&repo=hexo-theme-cicada&type=star&count=false&size=small" frameborder="0" scrolling="0" width="58px" height="30px" style="margin-bottom: -15px"></iframe></p>
</div>
</footer>

<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>


  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>


<!--  -->


  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-124632979-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-124632979-1');
  </script>


  <script type="text/javascript">
    var disqus_shortname = 'Shingooo';
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }());
  </script>


<script type="text/javascript" src="/js/cicada.js"></script>
  </body>
</html>